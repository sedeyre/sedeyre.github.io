// =====================================================================
// === CORE APP/CHART INITIALIZATION ===
// =====================================================================

const get_Json = fetch("json4datatable.json")
.then(function(response) {
    return response.json();
});

const make_charts = function() {
  get_Json.then(function(res) {
    google.charts.load('current', {
      callback: function () {
      drawChart(res);              
    },
    packages: ["calendar"]  
    });      
  });
};

make_charts();

// =====================================================================
// === VERGE3D UTILITY FUNCTIONS (Defined FIRST to prevent ReferenceErrors) ===
// =====================================================================

/**
 * Handles Fullscreen logic and returns a disposal function.
 * This MUST be defined before createApp to prevent ReferenceError.
 */
function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
  const container = document.getElementById(containerId);
  const fsButton = document.getElementById(fsButtonId);

  if (!fsButton) {
    return null;
  }
  if (!useFullscreen) {
    if (fsButton) fsButton.style.display = 'none';
    return null;
  }

  const fsEnabled = () => document.fullscreenEnabled
        || document.webkitFullscreenEnabled
        || document.mozFullScreenEnabled
        || document.msFullscreenEnabled;
  const fsElement = () => document.fullscreenElement
        || document.webkitFullscreenElement
        || document.mozFullScreenElement
        || document.msFullscreenElement;
  const requestFs = elem => (elem.requestFullscreen
        || elem.mozRequestFullScreen
        || elem.webkitRequestFullscreen
        || elem.msRequestFullscreen).call(elem);
  const exitFs = () => (document.exitFullscreen
        || document.mozCancelFullScreen
        || document.webkitExitFullscreen
        || document.msExitFullscreen).call(document);
  const changeFs = () => {
    const elem = fsElement();
    fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
    fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');

    // Update the visibility of the closeOverlay button
    const button = document.getElementById('closeOverlay');
    if (button) {
        button.style.display = elem ? 'none' : 'block';
  }    
    // Manually trigger resize event
    window.dispatchEvent(new Event('resize'));    
  };

  function fsButtonClick(event) {
    let button = document.getElementById('closeOverlay');
    event.stopPropagation();
    if (fsElement()) {
      button.style.display = 'block';
        exitFs();
    } else {
      button.style.display = 'none';
        requestFs(container);
    }
    // Manually trigger resize event
    window.dispatchEvent(new Event('resize'));
  }

  if (fsEnabled()) {
    fsButton.style.display = 'inline';
  }
  else {
    let button = document.getElementById('closeOverlay');
    button.style.display = 'block';
  }

  fsButton.addEventListener('click', fsButtonClick);
  document.addEventListener('webkitfullscreenchange', changeFs);
  document.addEventListener('mozfullscreenchange', changeFs);
  document.addEventListener('msfullscreenchange', changeFs);
  document.addEventListener('fullscreenchange', changeFs);

  const disposeFullscreen = () => {
    fsButton.removeEventListener('click', fsButtonClick);
    document.removeEventListener('webkitfullscreenchange', changeFs);
    document.removeEventListener('mozfullscreenchange', changeFs);
    document.removeEventListener('msfullscreenchange', changeFs);
    document.removeEventListener('fullscreenchange', changeFs);
  }

  return disposeFullscreen;
}

/**
 * Creates the Verge3D application instance.
 */
function createAppInstance(containerId, initOptions, preloader, PE) {
  const ctxSettings = {};
  if (initOptions.useBkgTransp) ctxSettings.alpha = true;
  if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

  const app = new v3d.App(containerId, ctxSettings, preloader);
  if (initOptions.useBkgTransp) {
      app.clearBkgOnLoad = true;
      if (app.renderer) {
          app.renderer.setClearColor(0x000000, 0);
      }
  }

  // namespace for communicating with code generated by Puzzles
  app.ExternalInterface = {};
  prepareExternalInterface(app);
  if (PE) PE.viewportUseAppInstance(app);

  return app;
}

/**
 * Sets up the ExternalInterface namespace on the app instance 
 * for communication with Verge3D Puzzles.
 */
function prepareExternalInterface(app) {
  // Placeholder, keep it empty if not used by Puzzles
}

/**
 * Handles the creation of the preloader instance.
 */
function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new v3d.SimplePreloader({ container: containerId });              

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

/**
 * Creates a custom preloader class.
 */
function createCustomPreloader(updateCb, finishCb) {
    class CustomPreloader extends v3d.Preloader {
        constructor() {
            super();
        }

        onUpdate(percentage) {
            super.onUpdate(percentage);
            if (updateCb) updateCb(percentage);
        }

        onFinish() {
            super.onFinish();
            if (finishCb) finishCb();
        }
    }

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
  const _onUpdate = preloader.onUpdate.bind(preloader);
  preloader.onUpdate = function(percentage) {
      _onUpdate(percentage);
      PE.loadingUpdateCb(percentage);
  }

  const _onFinish = preloader.onFinish.bind(preloader);
  preloader.onFinish = function() {
      _onFinish();
      PE.loadingFinishCb();
  }
}

// =====================================================================
// === VERGE3D LIFECYCLE MANAGEMENT ===
// =====================================================================

/**
 * Tracks the currently active Verge3D application instance. 
 */
let activeAppInstance = null;

async function createApp({containerId, fsButtonId = null, sceneURL, logicURL = ''}) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    v3d.Cache.enabled = false;

    let PL = null, PE = null;

    if (v3d.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = v3d.PE;
    } else if (v3d.AppUtils.isJS(logicURL)) {
        PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    // prepareFullscreen is now defined above and accessible
    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
            initOptions.useFullscreen);
    
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    
    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    
    app.loadScene(sceneURL, () => {
        app.enableControls();          
        app.run();
        
        if (PE) PE.updateAppInstance(app);
        // PL.init runs visual_logic.js which requires controls to be enabled
        if (PL) PL.init(app, initOptions); 

        removeSpecificElement();

    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL, PE, disposeFullscreen };
}

function openOverlay(ship_path) {
    // 1. Dispose of the previous app if it exists
    if (activeAppInstance) {
        console.log('Disposing previous Verge3D application instance...');
        closeOverlayAndDisposeApp();
        activeAppInstance = null; // Re-assignment after disposal function runs
    }

    // ACTIVATE THE SHROUD 
    const shroud = document.getElementById('calendar-shroud');
    if (shroud) {
        shroud.style.display = 'block';
    }

    const params = v3d.AppUtils.getPageParams();

    // 2. The createApp function will now handle setting and returning the instance
    createApp({
        containerId: 'v3d-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || ship_path,
        logicURL: params.logic || 'app/visual_logic.js',
    }).then(result => {
        if (result && result.app) {
            // Store the new active instance and its associated variables
            activeAppInstance = {
                app: result.app,
                PL: result.PL,
                PE: result.PE,
                disposeFullscreen: result.disposeFullscreen
            };
            
            setupCloseOverlayListener();
        }
    });

    const overlay_ship = document.getElementById('overlay_ship');
    // Display the overlay
    overlay_ship.style.display = 'block';
    requestAnimationFrame(() => {
        overlay_ship.style.opacity = '1';
        hideCalendarHoverLabel(); // hide calendar hover label
    }); 
}

/**
 * Disposes the active Verge3D application and hides the overlay.
 * This is the crucial step to free up WebGL context and memory.
 */
function closeOverlayAndDisposeApp() {
    if (activeAppInstance && activeAppInstance.app) {
        
        // ⭐ FIX: Explicitly dispose of the camera controls first.
        // This removes event listeners from the 'domElement', preventing the 'null' error.
        if (activeAppInstance.app.controls && typeof activeAppInstance.app.controls.dispose === 'function') {
            console.log('Disposing Verge3D controls...');
            activeAppInstance.app.controls.dispose();
        }
        
        activeAppInstance.app.dispose(); // Primary memory/context release call
        
        // Remove the fullscreen event listeners
        if (activeAppInstance.disposeFullscreen) {
            activeAppInstance.disposeFullscreen();
        }
        
        console.log('Verge3D application disposed successfully.');
    }
    
    // Reset the persistent reference
    activeAppInstance = null;
    
    // Hide the overlay
    const overlay_ship = document.getElementById('overlay_ship');
    if (overlay_ship) {
        overlay_ship.style.opacity = '0';
        // Use a timeout to ensure the canvas is removed after transition (optional but clean)
        setTimeout(() => {
            overlay_ship.style.display = 'none';
        }, 300); 
    }
    
    // Clean up the container's content (CRITICAL to clear old canvas element)
    const container = document.getElementById('v3d-container');
    if (container) {
        container.innerHTML = '';

        // ⭐ DEACTIVATE THE SHROUD
        const shroud = document.getElementById('calendar-shroud');
        if (shroud) {
            shroud.style.display = 'none';
        }
    }
}

/**
 * Sets up the event listener for the close button.
 */
function setupCloseOverlayListener() {
   const button_closeoverlay = document.getElementById('closeOverlay');
    
    if (button_closeoverlay) {
        // Ensure the listener is only attached once
        button_closeoverlay.onclick = closeOverlayAndDisposeApp;
        
    } else {
        console.error("Error: Could not find element with ID 'closeOverlay'. The close button listener was not set.");
    }
}

// =====================================================================
// === CALENDAR/BOOK FUNCTIONS (The rest of the original code) ===
// =====================================================================

function drawChart(json_obj) {

  var width = document.documentElement.clientWidth; // making chart responsive  
  var height = width*0.85;

  var dataTable = new google.visualization.DataTable();

  dataTable.addColumn({ type: 'date', id: 'Date' });
  dataTable.addColumn({ type: 'number', id: 'Capture' });
  dataTable.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
  dataTable.addColumn({ type: 'string', role: 'annotation' });
  
  
  // populate chart datatable
  for (let x in json_obj) {
    let d = new Date(json_obj[x].date);
              let date_options = {weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',  hour: 'numeric', minute: 'numeric'};
              let date_ = d.toLocaleDateString('en-us', date_options);
              let number__ = parseInt(d.getDate());
              let number_mod = number__.addSuffix();
              let date_mod = date_.replace(number__, number_mod);
              
    // Custom Tooltip HTML: Only shows the Date
              let tooltipHTML = `<div style="padding: 8px 12px; white-space: nowrap;">
                  <strong>${date_mod}</strong>
              </div>`;

    dataTable.addRows([
    [new Date(Date.parse(json_obj[x].date)), 1,tooltipHTML, createCustomHTMLContent(json_obj[x].img, date_mod, json_obj[x].name, json_obj[x].verse)]
    ]);
    }

  var chart = new google.visualization.Calendar(document.getElementById('calendar_basic'));

  let cellSize_ = width/56; // making chart responsive

  var options = {

    legend: 'none',
    title: '',
    focusTarget: 'none',       
    height: height,  
    width: width,          

    colorAxis: {
      colors:['#A3A2A1','#A3A2A1'],
      values: [1,0]          
    },

    tooltip: { isHtml: true },
    
    noDataPattern: {
      backgroundColor: '#161B26',
      color:  '#161B26'
    },

    calendar: {
      backgroundColor:'black',          
      cellSize: cellSize_,     // making chart responsive      
      daysOfWeek: 'smtwtfs',
      underYearSpace: 12,
      dayOfWeekRightSpace: 12,
      underMonthSpace: 10,            

      monthOutlineColor: {
        stroke: '#080e1a',
        strokeOpacity: 1,
        strokeWidth: 1
      },
      
      unusedMonthOutlineColor: {
        stroke: '#080e1a',
        strokeOpacity: 1,
        strokeWidth: 2
      },

      focusedCellColor: {
        stroke: '#8cc0d0ff',
        strokeOpacity: 1,
        strokeWidth: 0
      },

      cellColor: {
        stroke: '#080e1a',      // Color the border of the squares.
        strokeOpacity: 0, // Make the borders half transparent.
        strokeWidth: cellSize_/3.5     // making chart responsive
      },

      dayOfWeekLabel: {
        fontName: 'Courier New',
        fontSize: 16,
        color: '#D1CDCA',
        bold: false,
        italic: false,
      },

      monthLabel: {
        fontName: 'Courier New',
        fontSize: 17,
        color: '#D1CDCA',
        bold: false,
        italic: false
      },

      yearLabel: {
        fontName: 'Courier New',
        fontSize: 20,
        color: '#D1CDCA',
        bold: false,
        italic: false
      }          
    }
  };

  // hide chart heatmap legend in the upright  corner
  google.visualization.events.addListener(chart, 'ready', function () {
    $($('#calendar_basic text')[0]).hide();
    $($('#calendar_basic text')[1]).hide();
    $($('#calendar_basic text')[2]).hide();
    $('#calendar_basic linearGradient').hide();
    $('#calendar_basic')
      .find('[fill-opacity="1"]').hide();
  });

  chart.draw(dataTable, options);

  // Add click event listener
 google.visualization.events.addListener(chart, 'select', () => {
    let sel = chart.getSelection();
    if (!sel.length) return;

    let row = sel[0].row;
    if (row == null) return;

    if (json_obj[row] && json_obj[row].ship) {
      openOverlay(json_obj[row].ship);
      return;
    } 

    let html = dataTable.getValue(row, 3);
    if (html) {
      openOverlay_regular(html);
    }
  });

}

// adding the ordinal suffix, turning 1, 2 and 3 into 1st, 2nd and 3rd
Number.prototype.addSuffix = function() {
  var n = this.toString().split('.')[0];
  var lastDigits = n.substring(n.length - 2);
  //add exception just for 11, 12 and 13
  if(lastDigits==='11' || lastDigits==='12' || lastDigits==='13'){
      return this+'<sup>th</sup>';
  }
  switch(n.substring(n.length - 1)) {
      case '1': return this+'<sup>st</sup>';
      case '2': return this+'<sup>nd</sup>';
      case '3': return this+'<sup>rd</sup>';
      default : return this+'<sup>th</sup>';
  }
};

function fadeOut(element) {
  element.style.opacity = '0'; // Start fade out
  setTimeout(() => {
      element.style.display = 'none'; // Hide after transition
  }, 500); // Matches transition duration (0.5s)
}

function createCustomHTMLContent(imgURL, event_time, event, verse) {
  
  return '<div class="container">' + 
    '<div class="image">' + '<img src="' + imgURL + '">' +
    '</div>' +    
      '<div class="text">'+'<p>'+verse+'</p>'+'<p id="event_">'+'Sky object '+event+'<br/>'+event_time+'</p>'+
      '</div>' +        
  '</div>';              
}

// Function to remove the specific element
function removeSpecificElement() {
  if (document.querySelector('a[href="https://www.soft8soft.com/verge3d-trial/"]')) {
    var element = document.querySelector('a[href="https://www.soft8soft.com/verge3d-trial/"]');
    element.parentNode.removeChild(element);
    element.classList.remove('hidden-by-script');
  return;
  }
}

function openOverlay_regular(html) {
  const overlay = document.getElementById('overlay_regular');
  const content = document.getElementById('overlay_regular_content');

  if (!overlay || !content) {
    console.error('Overlay elements not found in openOverlay_regular.');
    return;
  }

  // Insert your custom HTML
  content.innerHTML = html;

  // Show overlay
  overlay.style.display = 'block';
  requestAnimationFrame(() => {
    overlay.style.opacity = '1';
    hideCalendarHoverLabel(); // hide calendar hover label
  });

  // Remove previous listener to avoid duplicates
  content.onmouseleave = null;

  // Close overlay when mouse leaves the content box
  content.addEventListener('mouseleave', () => {
    // fade out overlay
    overlay.style.opacity = '0';
    setTimeout(() => {
      overlay.style.display = 'none';
      showCalendarHoverLabel(); // restore calendar hover label
    }, 200);
  }, { once: true });
}

function hideCalendarHoverLabel() {
  const labels = document.querySelectorAll('#calendar_basic .google-visualization-tooltip');
  labels.forEach(el => {
    el.style.display = 'none';
  });
}

function showCalendarHoverLabel() {
  const labels = document.querySelectorAll('#calendar_basic .google-visualization-tooltip');
  labels.forEach(el => {
    el.style.display = '';
  });
}

function switchOn_b1() {  

  document.getElementById("calendar_basic").className = "calendar_basic_0";

  document.getElementById("blocks").style.display = "flex"; 
  document.getElementById("blocks").style.visibility = "visible";

  document.getElementById("book").className = "book_0";
}  
function switchOn_b2() {

  document.getElementById("blocks").style.display = "none";
  document.getElementById("menu").className = "menu_0";

  setTimeout(menu_none, 500);
  setTimeout(calendar_on, 600);

  document.getElementById("book").className = "book_0";  
}
function switchOn_b4() {

  document.getElementById("blocks").style.display = "none";
  document.getElementById("calendar_basic").style.display ="none";

  document.getElementById("menu").className = "menu_0";
  document.getElementById("logo").className = "logo_0";

  setTimeout(menu_none, 500);
  setTimeout(logo_none, 500);
  setTimeout(book_on, 1200);
  
}
function menu_none() {
  document.getElementById("menu").style.display = "none";
}
function logo_none() {
  document.getElementById("logo").style.display = "none";
}
function book_on() {
  document.getElementById("book").className = "book_1";
}
function calendar_on() {
  document.getElementById("calendar_basic").className = "calendar_basic_1";
  document.getElementById("calendar_basic").style.display ="block";
}
function makeBook(json_Obj) {      

  var count = -1;
  var entries_count = json_Obj.length;
  // define number of pages + n-starters
  var last_page = (entries_count * 2) +3;
  // define overall number of slider's range + n-closers
  $("input").attr('max', last_page +4);

  var slider = document.getElementById("slideRange");
  var output = document.getElementById("volume");
  var eventdate = document.getElementById("event_date");     
  // output.innerHTML = slider.value;
  // eventdate.innerHTML = "date";        

  $("#book").turn({
                  pages: last_page,                                                  
                  duration: 2000,
                  gradients: true,
                  turnCorners: "bl,br",
                  elevation: 100,                           
                  autoCenter: true});      

  for (let page = 4; page <= last_page; page++) {
         
      if ((page % 2) == 0) {
          count++;                   
          addPage(page, json_Obj, count, $("#book"));   
      }
      else {
          if (page == 5) {
              let count_odd = count;
              addPage(page, json_Obj, count_odd, $("#book"));
          }
          else {
              let count_odd = count;
              addPage(page, json_Obj, count_odd, $("#book"));
          }
      }
  }

  // add closers
  var last_page0 = last_page +1;
  var last_page1 = last_page +2;
  var last_page2 = last_page +3;          

  let html_page_last = ``;                                      
              var element = $("<div />").html(html_page_last).addClass("page");
  let html_hard0 = ``;                                      
              var element_hard0 = $("<div />").html(html_hard0).addClass("hard");
  let html_hard1 = ``;                                      
              var element_hard1 = $("<div />").html(html_hard1).addClass("hard");
  
  $("#book").turn("addPage", element, last_page0);
  $("#book").turn("addPage", element_hard0, last_page1);
  $("#book").turn("addPage", element_hard1, last_page2);      

  slider.oninput = function() {
      let page_ = this.value;
      // make last odd closer page accesable: 
      // if step="2" we can't see the third (even) closer page as a last odd page is NaN  
      if (page_ == last_page +4) {
          page_ = last_page +3;
          $("#book").turn("page", page_);
      }
      else {
          // output.innerHTML = this.value;
          $("#book").turn("page", page_);                
      }
  }

  // $("#book").bind("turning", function (event, page) {
  //     $("input[type=range]").val(page);
  //     // output.innerHTML = page;
  //     // eventdate.innerHTML = $(`#${page}`).text();                 
  // })

  // $("#book").bind("turned", function(event, page) {            
      // eventdate.innerHTML = $(`#${page}`).text();
      // bubbleOff();
  // })

  // const allRanges = document.querySelectorAll(".slidecontainer");
  //     allRanges.forEach(wrap => {
  //     const range = wrap.querySelector(".slider");
  //     const bubble = wrap.querySelector(".bubble");

  //     range.addEventListener("input", () => {
  //         setBubble(range, bubble);
  //     });
  //     setBubble(range, bubble);
  //     });

  // function setBubble(range, bubble) {
  //     const val = range.value;
  //     const min = range.min ? range.min : 0;
  //     const max = range.max ? range.max : 100;
  //     const newVal = Number(((val - min) * 22) / (max - min));
  //     let p = $("#book").turn("page");
  //     if (val == 1) {
  //         bubble.innerHTML = "Cover";
  //     }
  //     else {
  //         if (val == 3) {
  //         bubbleOff();
  //     }
  //         else {
  //         bubbleOn();
  //         bubble.innerHTML = $(`#${p}`).text();
  //         }
  //     }            
  //     // Sorta magic numbers based on size of the native UI thumb
  //     bubble.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
  // }

  // var bubble_V = document.getElementById("bubble_date");            
  
  // function bubbleOn() {
  //     bubble_V.style.display = "block";
  //     // bubble_V.style = "bubble";
  // }
  // function bubbleOff() {
  //     // bubble_V.style = "bubble";
  //     bubble_V.style.display = "none";
  // }
  // turn on/off slider bubble
  // slider.addEventListener('mousedown', bubbleOn);
  // slider.addEventListener('mouseup', bubbleOff);
  // slider.addEventListener('wheel', bubbleOn);  
  bookclick();
  function bookclick() {
    $("#bt_book").attr("onclick", "switchOn_b4()");
  }
}
function addPage(page, json_Obj, count, book) {
  
  let page_data = json_Obj[count];

  if (!book.turn('hasPage', page)) {

      if (page % 2==0) {
                  
              let html = `<img src=${page_data.img} class="insights">`; 
              var elementImage = $("<div />").html(html);
              book.turn('addPage', elementImage, page);                                             
          }

      else {
  
              let html = `<p class="verse">${page_data.verse}</p>
                          <p id="${page}" class="date">${page_data.date}</p>`;                     
              var elementVerse = $("<div />").html(html);
              book.turn('addPage', elementVerse, page);                       
          }                                          
     }
}
// make responsive
window.addEventListener('resize', function (e) {
  var chart = document.getElementById("calendar_basic");
  if (chart.style.display == "block") {
    make_charts();
  }
  // else {
  //   var book = document.getElementById("book");
  //   book.style.width = '';
  //   book.style.height = '';
  //   $(book).turn('size', book.clientWidth, book.clientHeight);
  // }
});