// main.js

// =====================================================================
// === GLOBAL VARIABLES & INITIAL DATA FETCH ===
// =====================================================================
let global_json_data = null;
let resizeTimer; 

const get_Json = fetch("json4datatable.json")
.then(function(response) {
    return response.json();
});

const make_charts = function() {
  get_Json.then(function(res) {
    // Store data globally for use in the resize handler
    global_json_data = res; 
    
    google.charts.load('current', {
      callback: function () {
      drawChart(res);              
    },
    packages: ["calendar"]  
    });      
  });
};

make_charts();

// =====================================================================
// === VERGE3D UTILITY FUNCTIONS (Defined FIRST to prevent ReferenceErrors) ===
// =====================================================================

/**
 * Handles Fullscreen logic and returns a disposal function.
 * This MUST be defined before createApp to prevent ReferenceError.
 */
function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
  const container = document.getElementById(containerId);
  const fsButton = document.getElementById(fsButtonId);

  if (!fsButton) {
    return null;
  }
  if (!useFullscreen) {
    if (fsButton) fsButton.style.display = 'none';
    return null;
  }

  const fsEnabled = () => document.fullscreenEnabled
        || document.webkitFullscreenEnabled
        || document.mozFullScreenEnabled
        || document.msFullscreenEnabled;
  const fsElement = () => document.fullscreenElement
        || document.webkitFullscreenElement
        || document.mozFullScreenElement
        || document.msFullscreenElement;
  const requestFs = elem => (elem.requestFullscreen
        || elem.mozRequestFullScreen
        || elem.webkitRequestFullscreen
        || elem.msRequestFullscreen).call(elem);
  const exitFs = () => (document.exitFullscreen
        || document.mozCancelFullScreen
        || document.webkitExitFullscreen
        || document.msExitFullscreen).call(document);
  const changeFs = () => {
    const elem = fsElement();
    fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
    fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');

    // Update the visibility of the closeOverlay button
    const button = document.getElementById('closeOverlay');
    if (button) {
        button.style.display = elem ? 'none' : 'block';
  }    
    // Manually trigger resize event
    window.dispatchEvent(new Event('resize'));    
  };

  function fsButtonClick(event) {
    let button = document.getElementById('closeOverlay');
    event.stopPropagation();
    if (fsElement()) {
      button.style.display = 'block';
        exitFs();
    } else {
      button.style.display = 'none';
        requestFs(container);
    }
    // Manually trigger resize event
    window.dispatchEvent(new Event('resize'));
  }

  if (fsEnabled()) {
    fsButton.style.display = 'inline';
  }
  else {
    let button = document.getElementById('closeOverlay');
    button.style.display = 'block';
  }

  fsButton.addEventListener('click', fsButtonClick);
  document.addEventListener('webkitfullscreenchange', changeFs);
  document.addEventListener('mozfullscreenchange', changeFs);
  document.addEventListener('msfullscreenchange', changeFs);
  document.addEventListener('fullscreenchange', changeFs);

  const disposeFullscreen = () => {
    fsButton.removeEventListener('click', fsButtonClick);
    document.removeEventListener('webkitfullscreenchange', changeFs);
    document.removeEventListener('mozfullscreenchange', changeFs);
    document.removeEventListener('msfullscreenchange', changeFs);
    document.removeEventListener('fullscreenchange', changeFs);
  }

  return disposeFullscreen;
}

/**
 * Creates the Verge3D application instance.
 */
function createAppInstance(containerId, initOptions, preloader, PE) {
  const ctxSettings = {};
  if (initOptions.useBkgTransp) ctxSettings.alpha = true;
  if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

  const app = new v3d.App(containerId, ctxSettings, preloader);
  if (initOptions.useBkgTransp) {
      app.clearBkgOnLoad = true;
      if (app.renderer) {
          app.renderer.setClearColor(0x000000, 0);
      }
  }

  // namespace for communicating with code generated by Puzzles
  app.ExternalInterface = {};
  prepareExternalInterface(app);
  if (PE) PE.viewportUseAppInstance(app);

  return app;
}

/**
 * Sets up the ExternalInterface namespace on the app instance 
 * for communication with Verge3D Puzzles.
 */
function prepareExternalInterface(app) {
  // Placeholder, keep it empty if not used by Puzzles
}

/**
 * Handles the creation of the preloader instance.
 */
function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new v3d.SimplePreloader({ container: containerId });              

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

/**
 * Creates a custom preloader class.
 */
function createCustomPreloader(updateCb, finishCb) {
    class CustomPreloader extends v3d.Preloader {
        constructor() {
            super();
        }

        onUpdate(percentage) {
            super.onUpdate(percentage);
            if (updateCb) updateCb(percentage);
        }

        onFinish() {
            super.onFinish();
            if (finishCb) finishCb();
        }
    }

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
  const _onUpdate = preloader.onUpdate.bind(preloader);
  preloader.onUpdate = function(percentage) {
      _onUpdate(percentage);
      PE.loadingUpdateCb(percentage);
  }

  const _onFinish = preloader.onFinish.bind(preloader);
  preloader.onFinish = function() {
      _onFinish();
      PE.loadingFinishCb();
  }
}

// =====================================================================
// === VERGE3D LIFECYCLE MANAGEMENT ===
// =====================================================================

/**
 * Tracks the currently active Verge3D application instance. 
 */
let activeAppInstance = null;

async function createApp({containerId, fsButtonId = null, sceneURL, logicURL = ''}) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    v3d.Cache.enabled = false;

    let PL = null, PE = null;

    if (v3d.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = v3d.PE;
    } else if (v3d.AppUtils.isJS(logicURL)) {
        PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    // prepareFullscreen is now defined above and accessible
    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
            initOptions.useFullscreen);
    
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    
    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    
    app.loadScene(sceneURL, () => {
        app.enableControls();          
        app.run();
        
        if (PE) PE.updateAppInstance(app);
        // PL.init runs visual_logic.js which requires controls to be enabled
        if (PL) PL.init(app, initOptions); 

        removeSpecificElement();

    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL, PE, disposeFullscreen };
}

function openOverlay(ship_path) {
    // 1. Dispose of the previous app if it exists
    if (activeAppInstance) {
        console.log('Disposing previous Verge3D application instance...');
        closeOverlayAndDisposeApp();
        activeAppInstance = null; // Re-assignment after disposal function runs
    }

    // ACTIVATE THE SHROUD 
    const shroud = document.getElementById('calendar-shroud');
    if (shroud) {
        shroud.style.display = 'block';
    }

    const params = v3d.AppUtils.getPageParams();

    // 2. The createApp function will now handle setting and returning the instance
    createApp({
        containerId: 'v3d-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || ship_path,
        logicURL: params.logic || 'app/visual_logic.js',
    }).then(result => {
        if (result && result.app) {
            // Store the new active instance and its associated variables
            activeAppInstance = {
                app: result.app,
                PL: result.PL,
                PE: result.PE,
                disposeFullscreen: result.disposeFullscreen
            };
            
            setupCloseOverlayListener();
        }
    });

    const overlay_ship = document.getElementById('overlay_ship');
    // Display the overlay
    overlay_ship.style.display = 'block';
    requestAnimationFrame(() => {
        overlay_ship.style.opacity = '1';
        hideCalendarHoverLabel(); // hide calendar hover label
    }); 
}

/**
 * Disposes the active Verge3D application and hides the overlay.
 * This is the crucial step to free up WebGL context and memory.
 */
function closeOverlayAndDisposeApp() {
    if (activeAppInstance && activeAppInstance.app) {
        
        // ⭐ FIX: Explicitly dispose of the camera controls first.
        // This removes event listeners from the 'domElement', preventing the 'null' error.
        if (activeAppInstance.app.controls && typeof activeAppInstance.app.controls.dispose === 'function') {
            console.log('Disposing Verge3D controls...');
            activeAppInstance.app.controls.dispose();
        }
        
        activeAppInstance.app.dispose(); // Primary memory/context release call
        
        // Remove the fullscreen event listeners
        if (activeAppInstance.disposeFullscreen) {
            activeAppInstance.disposeFullscreen();
        }
        
        console.log('Verge3D application disposed successfully.');
    }
    
    // Reset the persistent reference
    activeAppInstance = null;
    
    // Hide the overlay
    const overlay_ship = document.getElementById('overlay_ship');
    if (overlay_ship) {
        overlay_ship.style.opacity = '0';
        // Use a timeout to ensure the canvas is removed after transition (optional but clean)
        setTimeout(() => {
            overlay_ship.style.display = 'none';
        }, 300); 
    }
    
    // Clean up the container's content (CRITICAL to clear old canvas element)
    const container = document.getElementById('v3d-container');
    if (container) {
        container.innerHTML = '';

        // ⭐ DEACTIVATE THE SHROUD
        const shroud = document.getElementById('calendar-shroud');
        if (shroud) {
            shroud.style.display = 'none';
        }
    }
}

/**
 * Sets up the event listener for the close button.
 */
function setupCloseOverlayListener() {
   const button_closeoverlay = document.getElementById('closeOverlay');
    
    if (button_closeoverlay) {
        // Ensure the listener is only attached once
        button_closeoverlay.onclick = closeOverlayAndDisposeApp;
        
    } else {
        console.error("Error: Could not find element with ID 'closeOverlay'. The close button listener was not set.");
    }
}

// =====================================================================
// === CALENDAR/BOOK FUNCTIONS 
// =====================================================================

function drawChart(json_obj) {
  
  // --- 1. Dynamic Height Calculation Logic ---

  // 1a. Count the unique years in the dataset
  const years = new Set();
  json_obj.forEach(item => {
      if (item.date) {
          years.add(new Date(item.date).getFullYear());
      }
  });
  const numberOfYears = years.size;
  if (numberOfYears === 0) {
      console.warn('No data found to draw calendar chart.');
      return; 
  }
  // ---------------------------------------------

  var width = document.documentElement.clientWidth; // making chart responsive  
  // var height = document.documentElement.clientHeight; // Removed, using calculated height

  var dataTable = new google.visualization.DataTable();

  dataTable.addColumn({ type: 'date', id: 'Date' });
  dataTable.addColumn({ type: 'number', id: 'Capture' });
  dataTable.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
  dataTable.addColumn({ type: 'string', role: 'annotation' });
  
  
  // populate chart datatable
  for (let x in json_obj) {
    let d = new Date(json_obj[x].date);
              let date_options = {weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',  hour: 'numeric', minute: 'numeric'};
              let date_ = d.toLocaleDateString('en-us', date_options);
              let number__ = parseInt(d.getDate());
              let number_mod = number__.addSuffix();
              let date_mod = date_.replace(number__, number_mod);
              
    // Custom Tooltip HTML: Only shows the Date
              let tooltipHTML = `<div style="padding: 8px 12px; white-space: nowrap;">
                  <strong>${date_mod}</strong>
              </div>`;

    dataTable.addRows([
    [new Date(Date.parse(json_obj[x].date)), 1,tooltipHTML, createCustomHTMLContent(json_obj[x].img, date_mod, json_obj[x].name, json_obj[x].verse)]
    ]);
    }

  var chart = new google.visualization.Calendar(document.getElementById('calendar_basic'));

  let cellSize_ = width/56; // making chart responsive
  
  // 1b. Calculate the estimated required height
  const CALENDAR_HEIGHT_MULTIPLIER = 8.7; // Empirical multiplier for 1 year's height based on cellSize_
  const underYearSpace = 12; // From your options: calendar.underYearSpace
  
  // Height for one year block: (Multiplier * CellSize) + UnderYearSpace
  const heightPerYearBlock = (CALENDAR_HEIGHT_MULTIPLIER * cellSize_) + underYearSpace;
  
  // Total Estimated Height: (Number of Years * Height per Year Block) + small padding reserve
  var estimatedHeight = (numberOfYears * heightPerYearBlock) + 20;


  var options = {

    legend: 'none',
    title: '',
    focusTarget: 'none',       
    height: estimatedHeight, // <-- CRITICAL CHANGE: Use the calculated height
    width: width,          

    colorAxis: {
      colors:['#A3A2A1','#A3A2A1'],
      values: [1,0]          
    },

    tooltip: { isHtml: true },
    
    noDataPattern: {
      backgroundColor: '#161B26',
      color:  '#161B26'
    },

    calendar: {
      backgroundColor:'black',          
      cellSize: cellSize_,     // making chart responsive      
      daysOfWeek: 'smtwtfs',
      underYearSpace: underYearSpace,
      dayOfWeekRightSpace: width/150,
      dayOfWeekLeftSpace: width/120,
      underMonthSpace: 10,            

      monthOutlineColor: {
        stroke: '#080e1a',
        strokeOpacity: 1,
        strokeWidth: 1
      },
      
      unusedMonthOutlineColor: {
        stroke: '#080e1a',
        strokeOpacity: 1,
        strokeWidth: 2
      },

      focusedCellColor: {
        stroke: '#8cc0d0ff',
        strokeOpacity: 1,
        strokeWidth: 0
      },

      cellColor: {
        stroke: '#080e1a',      // Color the border of the squares.
        strokeOpacity: 0, // Make the borders half transparent.
        strokeWidth: cellSize_/3.5     // making chart responsive
      },

      dayOfWeekLabel: {
        fontName: 'Courier New',
        // fontSize: 16,
        color: '#D1CDCA',
        bold: true,
        italic: false,
      },

      monthLabel: {
        fontName: 'Courier New',
        // fontSize: 17,
        color: '#D1CDCA',
        bold: true,
        italic: false
      },

      yearLabel: {
        fontName: 'Courier New',
        fontSize: width/70,
        color: '#D1CDCA',
        bold: true,
        italic: false
      }          
    }
  };

  // hide chart heatmap legend in the upright  corner
  google.visualization.events.addListener(chart, 'ready', function () {
    $($('#calendar_basic text')[0]).hide();
    $($('#calendar_basic text')[1]).hide();
    $($('#calendar_basic text')[2]).hide();
    $('#calendar_basic linearGradient').hide();
    $('#calendar_basic')
      .find('[fill-opacity="1"]').hide();
  });

  chart.draw(dataTable, options);

  // Add click event listener
 google.visualization.events.addListener(chart, 'select', () => {
    let sel = chart.getSelection();
    if (!sel.length) return;

    let row = sel[0].row;
    if (row == null) return;

    if (json_obj[row] && json_obj[row].ship) {
      openOverlay(json_obj[row].ship);
      return;
    } 

    let html = dataTable.getValue(row, 3);
    if (html) {
      openOverlay_regular(html);
    }
  });

}

// adding the ordinal suffix, turning 1, 2 and 3 into 1st, 2nd and 3rd
Number.prototype.addSuffix = function() {
  var n = this.toString().split('.')[0];
  var lastDigits = n.substring(n.length - 2);
  //add exception just for 11, 12 and 13
  if(lastDigits==='11' || lastDigits==='12' || lastDigits==='13'){
      return this+'<sup>th</sup>';
  }
  switch(n.substring(n.length - 1)) {
      case '1': return this+'<sup>st</sup>';
      case '2': return this+'<sup>nd</sup>';
      case '3': return this+'<sup>rd</sup>';
      default : return this+'<sup>th</sup>';
  }
};

function fadeOut(element) {
  element.style.opacity = '0'; // Start fade out
  setTimeout(() => {
      element.style.display = 'none'; // Hide after transition
  }, 500); // Matches transition duration (0.5s)
}

function createCustomHTMLContent(imgURL, event_time, event, verse) {
  
  return '<div class="container">' + 
    '<div class="image">' + '<img src="' + imgURL + '">' +
    '</div>' +    
      '<div class="text">'+'<p>'+verse+'</p>'+'<p id="event_">'+'Sky object '+event+'<br/>'+event_time+'</p>'+
      '</div>' +        
  '</div>';              
}

// Function to remove the specific element
function removeSpecificElement() {
  if (document.querySelector('a[href="https://www.soft8soft.com/verge3d-trial/"]')) {
    var element = document.querySelector('a[href="https://www.soft8soft.com/verge3d-trial/"]');
    element.parentNode.removeChild(element);
    element.classList.remove('hidden-by-script');
  return;
  }
}

function openOverlay_regular(html) {
  const overlay = document.getElementById('overlay_regular');
  const content = document.getElementById('overlay_regular_content');

  if (!overlay || !content) {
    console.error('Overlay elements not found in openOverlay_regular.');
    return;
  }

  // Insert your custom HTML
  content.innerHTML = html;

  // Show overlay
  overlay.style.display = 'block';
  requestAnimationFrame(() => {
    overlay.style.opacity = '1';
    hideCalendarHoverLabel(); // hide calendar hover label
  });

  // Remove previous listener to avoid duplicates
  content.onmouseleave = null;

  // Close overlay when mouse leaves the content box
  content.addEventListener('mouseleave', () => {
    // fade out overlay
    overlay.style.opacity = '0';
    setTimeout(() => {
      overlay.style.display = 'none';
      showCalendarHoverLabel(); // restore calendar hover label
    }, 200);
  }, { once: true });
}

function hideCalendarHoverLabel() {
  const labels = document.querySelectorAll('#calendar_basic .google-visualization-tooltip');
  labels.forEach(el => {
    el.style.display = 'none';
  });
}

function showCalendarHoverLabel() {
  const labels = document.querySelectorAll('#calendar_basic .google-visualization-tooltip');
  labels.forEach(el => {
    el.style.display = '';
  });
}

// make responsive - UPDATED TO USE DEBOUNCING AND GLOBAL DATA
window.addEventListener('resize', function (e) {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
      var chart = document.getElementById("calendar_basic");
      
      // Check if the chart is visible (or not explicitly hidden) AND data is loaded
      if (chart && chart.style.display !== "none" && global_json_data) {
          // Re-draw the chart, which recalculates all responsive dimensions (width, cellSize, height)
          drawChart(global_json_data); 
      }
      
      // Original logic for the 'book' element (assuming it's related to the Verge3D app or another component)
      // else {
      //   var book = document.getElementById("book");
      //   book.style.width = '';
      //   book.style.height = '';
      //   $(book).turn('size', book.clientWidth, book.clientHeight);
      // }
  }, 250); // Debounce time: 250ms
});